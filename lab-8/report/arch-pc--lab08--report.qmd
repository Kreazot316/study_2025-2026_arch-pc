---
## Author
author:
  name: Карпухин Клиим
  email: 1032255580@pfur.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6

## Title
title: "Отчёт по лабораторной работе No8"
subtitle: "Программирование цикла. Обработка аргументов командной строки."
license: "CC BY"
---

# Цель работы

Цель данной лабораторной работы — приобретение навыков написания программ на языке ассемблера NASM с использованием циклов и обработкой аргументов командной строки, а также закрепление знаний об организации стека и использовании инструкций `push` и `pop` для временного сохранения значений регистров.

# Выполнение лабораторной работы

## Реализация циклов в NASM

Создал каталог для программ лабораторной работы №8, перешёл в него и создал файл `lab8-1.asm` ([рис. @fig-001]).

![Создание каталога для программ лабораторной работы №8, переход в него и создание файла lab8-1.asm](image/1.jpg){#fig-001 width=70%}

Ввёл в файл `lab8-1.asm` текст программы из листинга 8.1, реализующей вывод значений регистра `ecx` с использованием инструкции `loop` ([рис. @fig-002]).

![Введённый текст программы вывода значений регистра ecx (листинг 8.1)](image/2.jpg){#fig-002 width=70%}

Создал объектный файл и исполняемый файл, затем запустил программу ([рис. @fig-003]).

![Создание объектного и исполняемого файла, запуск программы lab8-1](image/3.jpg){#fig-003 width=70%}

При запуске программы ввёл значение `N = 14`. Программа выводила последовательность значений регистра `ecx` от `14` до `1`, каждое значение — с новой строки.

Изменил текст программы, добавив явное изменение регистра `ecx` внутри тела цикла:

```{.asm}
label:
    sub ecx, 1
    mov [N], ecx
    mov eax, [N]
    call iprintLF
    loop label
```

([рис. @fig-004]).

![Изменённый текст программы с дополнительным изменением регистра ecx внутри цикла](image/4.jpg){#fig-004 width=70%}

Снова создал объектный и исполняемый файлы и запустил программу ([рис. @fig-005]).

![Создание и запуск исполняемого файла после изменения программы](image/5.jpg){#fig-005 width=70%}

После внесённых изменений:

- регистр `ecx` уменьшался **дважды** на каждой итерации — один раз явной командой `sub ecx, 1` и один раз внутри инструкции `loop`;
- количество проходов цикла стало меньше введённого `N`;
- выводились не все значения от `N` до `1`, а только часть (каждое второе значение), и цикл завершался раньше.

Сделал вывод, что при использовании инструкции `loop` нельзя произвольно изменять регистр `ecx` внутри тела цикла, иначе нарушается корректность работы счётчика.

Для сохранения корректности работы цикла внёс изменения в текст программы, добавив использование стека: перед локальным изменением `ecx` значение счётчика сохраняется в стек командой `push`, а после выполнения тела цикла восстанавливается командой `pop`. Модифицированный фрагмент программы имеет вид:

```{.asm}
label:
    push ecx
    sub ecx, 1
    mov [N], ecx
    mov eax, [N]
    call iprintLF
    pop ecx
    loop label
```

([рис. @fig-006]).

![Изменённый текст программы с использованием стека (push/pop) для сохранения счётчика цикла](image/6.jpg){#fig-006 width=70%}

Собрал и запустил программу ещё раз ([рис. @fig-007]).

![Создание и запуск исполняемого файла после добавления инструкций push/pop](image/7.jpg){#fig-007 width=70%}

После исправления:

- число проходов цикла снова стало равным введённому значению `N`;
- значения регистра `ecx` последовательно уменьшались от `N` до `1`;
- инструкция `loop` корректно использовала восстановленное значение `ecx` как счётчик, а временные изменения внутри тела цикла не нарушали логику работы цикла.

Таким образом, было продемонстрировано, как с помощью стека можно временно изменять регистр `ecx` внутри цикла, не нарушая работу инструкции `loop`.

## Обработка аргументов командной строки

### Программа вывода аргументов командной строки

Создал файл `lab8-2.asm` в каталоге `~/work/arch-pc/lab08` и ввёл в него текст программы из листинга 8.2, реализующей вывод аргументов командной строки ([рис. @fig-008]).

![Текст программы lab8-2.asm, обрабатывающей аргументы командной строки (листинг 8.2)](image/8.jpg){#fig-008 width=70%}

Текст программы использует стек для получения количества аргументов и имени программы, а затем в цикле извлекает и выводит каждый аргумент командной строки.

Собрал и запустил программу, передав ей несколько аргументов ([рис. @fig-009]).

![Запуск программы lab8-2 с несколькими аргументами командной строки и выводом каждого аргумента](image/9.jpg){#fig-009 width=70%}

Программой было обработано 4 аргумента, так как из-за отсутствия кавычек выражение "аргумент 2" попадает в программу как два отдельных аргумента --- "аргумент" и "2".

### Программа вычисления суммы аргументов командной строки

Создал файл `lab8-3.asm` в каталоге `~/work/arch-pc/lab08` и ввёл в него текст программы из листинга 8.3, вычисляющей сумму числовых аргументов командной строки ([рис. @fig-010]).

![Текст программы lab8-3.asm, вычисляющей сумму аргументов командной строки (листинг 8.3)](image/10.jpg){#fig-010 width=70%}

Собрал и запустил программу, передав ей набор числовых аргументов:

`./lab8-3 12 13 7 10 5`

([рис. @fig-011]).

![Создание и запуск программы lab8-3 с набором числовых аргументов, вывод суммы](image/11.jpg){#fig-011 width=70%}

### Модификация программы для вычисления произведения аргументов

По заданию изменил программу из листинга 8.3 так, чтобы она вычисляла не сумму, а произведение аргументов командной строки.

Для этого внёс в текст программы следующие изменения:

1. Изменил начальное значение аккумулятора:

   вместо инициализации нулём

   ```{.asm}
   mov esi, 0
   ```

   использовал единицу как нейтральный элемент умножения:

   ```{.asm}
   mov esi, 1
   ```

2. Заменил операцию сложения на умножение:

   вместо

   ```{.asm}
   add esi, eax
   ```

   использовал команду умножения:

   ```{.asm}
   imul esi, eax
   ```

([рис. @fig-012]).

![Изменённый текст программы lab8-3 для вычисления произведения аргументов](image/12.jpg){#fig-012 width=70%}

Собрал модифицированную программу и запустил её с набором числовых аргументов:

`./lab8-3 6 7 2`

([рис. @fig-013]).

![Создание и запуск модифицированной программы lab8-3, вычисляющей произведение аргументов](image/13.jpg){#fig-013 width=70%}

Программа корректно вычисляла произведение переданных аргументов:

- для набора `6 7 2` результатом было значение `84`;
- при добавлении новых аргументов произведение изменялось соответственно.

Таким образом, на основе программы суммирования аргументов была реализована программа для вычисления произведения аргументов командной строки с использованием цикла и стека.

## Задание для самостоятельной работы

### Задание 1. Сумма значений функции f(x) для набора аргументов

В соответствии с пунктом 8.4 лабораторной работы необходимо написать программу, которая вычисляет сумму значений функции

`f(x)`

для набора аргументов

`x = x₁, x₂, ..., xₙ`,

передаваемых через строку запуска программы.

Программа должна вычислять и выводить величину

`f(x₁) + f(x₂) + ... + f(xₙ)`.

Для своего варианта (вариант 1) использовал функцию `f(x)` согласно таблице 8.1 методических указаний.

Создал файл с программой `lab8-task1.asm` и реализовал в нём следующий алгоритм:

1. Извлёк из стека количество аргументов и имя программы.
2. Уменьшил счётчик аргументов на 1, чтобы не учитывать имя программы.
3. Инициализировал регистр ESI (аккумулятор суммы) нулём.
4. В цикле:
- извлекал из стека очередной аргумент в виде строки;
- преобразовывал его в число с помощью процедуры atoi;
- вычислял значение f(x) = 2x + 15;
- добавлял полученное значение к сумме в регистре ESI.
5.После окончания цикла вывел на экран:
- строку с указанием вида функции f(x) = 2x + 15;
- строку с текстом «Результат:» и вычисленным значением суммы.

Текст программы, реализующей вычисление суммы значений функции `f(x)` для набора аргументов, приведён на [рис. @fig-014].

![Текст программы, вычисляющей сумму значений функции f(x) для набора аргументов командной строки](image/14.jpg){#fig-014 width=70%}

Собрал и запустил программу с несколькими наборами аргументов `x₁, x₂, ..., xₙ`, проверяя корректность результата ([рис. @fig-015]).

![Запуск программы для нескольких наборов аргументов и проверка корректности результата](image/15.jpg){#fig-015 width=70%}

# Выводы

В ходе выполнения данной лабораторной работы:

- изучил работу инструкции `loop` и особенности использования регистра `ecx` в качестве счётчика цикла;
- познакомился с организацией стека и на практике использовал инструкции `push` и `pop` для временного сохранения значений регистров внутри цикла;
- реализовал программу вывода значений регистра `ecx` и исследовал влияние дополнительных изменений счётчика на количество итераций цикла;
- освоил обработку аргументов командной строки в NASM, реализовав программы для вывода аргументов, вычисления их суммы и произведения;
- выполнил задание для самостоятельной работы, написав программу, которая вычисляет сумму значений функции `f(x)` для набора аргументов, передаваемых через командную строку.

В результате выполнения работы были закреплены навыки программирования циклов на языке ассемблера NASM, работы со стеком и обработки аргументов командной строки, что является важным шагом к пониманию низкоуровневой организации программ и взаимодействия с операционной системой.
